# 챕터3에 대해서 정리해보자
1.연산자란?

연산 : 일정한 법칙에 따라 결과를 내는 것

연산자 : 연산을 하기 위해 사용하는 기호

피연산자 : 연산의 대상 값

단항 연산자 : 피연산자 한 개만 연산하는 연산자

이항 연산자 : 피연산자 두 개를 연산하는 연산자

2.산술 연산자

수학적인 계산에 사용되는 연산자. +, -, *, /, % 연산자가 있다.

숫자 피연산자(byte, short, char, int, long, float, double)를 연산하며 결과도 숫자를 반환한다.

연산 결과의 타입은 피연산자의 타입에 따라 달라진다. int 타입 보다 크기가 작은 타입(byte, short, char)은 int로 프로모션 되어 연산된다.

double → float → long → int 순으로 더 큰 타입이 있으면 프로모션 되어 연산된다.

ex) double 타입과 int 타입을 연산하면 int 값이 double값으로 프로모션 되어 연산 한 후 결과 값(double 타입)을 반환한다.

+ 연산자
  왼쪽의 피연산자에 오른쪽 피연산자를 더한 값을 반환한다.

단항 연산자로 쓰일 경우에는 양수를 의미한다.

문자열(String 타입)에서 쓰일 경우 왼쪽의 문자열 뒤에 오른쪽의 문자열을 합친 문자열을 반환한다.

- 연산자
  왼쪽의 피연산자에 오른쪽 피연산자를 뺀 값을 반환한다.

단항 연산자로 쓰인 경우 음수를 의미하며 0에서 피연산자를 뺀 값과 같다.

* 연산자
  왼쪽의 피연산자에 오른쪽 피연산자를 곱한 값을 반환한다.

/ 연산자
왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 값의 몫을 반환한다.

% 연산자
왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 값의 나머지를 반환한다.

3.비트 연산자

~, &, |, ^, <<, >>, >>> 연산자가 있다. 비트 연산자는 정수 혹은 부울(boolean) 피연산자를 연산한다. 비트 단위로 연산하며 결과값은 정수 혹은 부울값을 반환한다.

~ 연산자
단항 연산자. 정수로 표현 할 수 있는 피연산자를 연산한다. 비트 NOT 연산을 한다. 1이면 0으로, 0이면 1로 반전시킨다. 정수 값으로 ~a의 결과는 (-a) - 1와 같다.

int a = 0b11111111_11111111_11111111_11110000; //출력값 : -16

int b = 0b00000000_00000000_00000000_00001111; //출력값 : 15

int c = ~a; //출력값 : 15

& 연산자
비트 AND 연산이나 논리 AND 연산을 한다. 정수와 부울 피연산자를 연산한다.

비트 AND 연산 : 대응되는 비트가 모두 1이면 1을 반환하고 다른 경우 0을 반환한다.

논리 AND 연산 : 논리식이 모두 참이면 참을 반환한다.

int a = 0b00000000_00000000_00000000_00001111; //출력값 : 15

int b = 0b00000000_00000000_00000000_00000011; //출력값 : 3

int c = 0b00000000_00000000_00000000_00000011; //출력값 : 3

int d = a & b; //출력값 : 3

boolean aa = true;//출력값 : true

boolean bb = false;//출력값 : false

boolean cc = aa & bb;//출력값 : false

| 연산자
비트 OR 연산이나 논리 OR 연산을 한다. 정수와 부울 피연산자를 연산한다.

비트 OR 연산 : 대응되는 비트 중 하나라도 1이면 1을 반환하고 두 비트 모두 0일 때 0을 반환한다.

논리 OR 연산 : 논리식 중 하나라도 참이면 참을 반환한다.

int a = 0b00000000_00000000_00000000_00001111; //출력값 : 15

int b = 0b00000000_00000000_00000000_00000011; //출력값 : 3

int c = 0b00000000_00000000_00000000_00001111; //출력값 : 15

int d = a & b; //출력값 : 15

boolean aa = true;//출력값 : true

boolean bb = false;//출력값 : false

boolean cc = aa | bb;//출력값 : true

^ 연산자
비트 XOR 연산이나 논리 XOR 연산을 한다. 정수와 부울 피연산자를 연산한다.

비트 XOR 연산 : 대응되는 비트가 다르면 1을 반환하고 같으면 0을 반환한다.

논리 XOR 연산 : 논리식이 같으면 거짓을 반환하고 다르면 참을 반환한다.

int a = 0b00000000_00000000_00000000_00001111; //출력값 : 15

int b = 0b00000000_00000000_00000000_00000011; //출력값 : 3

int c = 0b00000000_00000000_00000000_00001100; //출력값 : 12

int d = a ^ b; //출력값 : 12

boolean aa = true;//출력값 : true

boolean bb = false;//출력값 : false

boolean cc = aa ^ bb;//출력값 : true

<< 연산자
왼쪽의 피연산자를 오른쪽 피연산자 만큼 왼쪽으로 이동시키고 빈 자리는 0으로 채운다. 정수 피연산자를 연산한다.

int a = 0b00000000_00000000_00000000_00000011;//출력 값 : 3

int b = 0b00000000_00000000_00000000_00001100;//출력 값 : 12

int c = a<<2;//출력 값 : 12

// >>연산자
왼쪽의 피연산자를 오른쪽 피연산자 만큼 오른쪽으로 이동시키고 부호를 유지시키기 위해서 빈자리는 가장 왼쪽 비트로 채운다. 정수 피연산자를 연산한다.

int a = 0b11111111_11111111_11111111_11110000;//출력 값 : -16

int b = 0b11111111_11111111_11111111_11111100;//출력 값 : -4

int c = a>>2;//출력 값 : -4

//  >>> 연산자
왼쪽의 피연산자를 오른쪽 피연산자 만큼 오른쪽으로 이동시키고 빈자리는 0으로 채운다. 정수 피연산자를 연산한다.

int a = 0b00000000_00000000_00000000_00001100;//출력 값 : 12

int b = 0b00000000_00000000_00000000_00000011;//출력 값 : 3

int c = a>>>2;//출력 값 : 3

4.관계 연산자

<, <=, >, >=, ==, != 연산자가 있다. 피연산자를 비교하는 연산자이다. 결과는 부울 값을 반환한다.

<, <=, >, >= 연산자
숫자 피연산자를 비교한다. 피연산자의 타입이 다르면 큰 유형으로 프로모션하여 비교한다.

//왼쪽의 피연산자가 오른쪽의 피연산자 보다 큰지 비교하여 결과를 반환한다.
boolean a = 1 > 2; //출력 값 : false

//왼쪽의 피연산자가 오른쪽의 피연산자 보다 크거나 같은지 비교하여 결과를 반환한다.
boolean b = 2 >= 2;//출력 값 : true

//왼쪽의 피연산자가 오른쪽의 피연산자 보다 작은지 비교하여 결과를 반환한다.
boolean c = 1 < 2;//출력 값 : true

//왼쪽의 피연산자가 오른쪽의 피연산자 보다 작거나 같은지 비교하여 결과를 반환한다.
boolean d = 2 <= 2;//출력 값 : true
==, != 연산자
피연산자가 같은지 비교한다. 피연산자는 모든 타입이 가능하며 레퍼런스 타입인 경우 동일한 객체를 참조하는지 비교한다.

String s1 = new String("abc");
String s2 = new String("abc");

//왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 참을 반환한다.
boolean a = 1 == 1; //출력 값 : true
boolean b = s1 == s2; //출력 값 : false

//왼쪽의 피연산자와 오른쪽의 피연산자가 다르면 참을 반환한다.
boolean c = 1 != 1; //출력 값 : false
boolean d = s1 != s2; //출력 값 : true

5.논리 연산자
!, &&, || 연산자가 있다. 부울 피연산자를 연산한다. 결과는 부울 값을 반환한다.

!, &&, || 연산자
//단항 연산자. 논리 NOT 연산을 한다.
boolean a = !true;// 출력 값 : false

//논리 AND 연산을 한다.
boolean b = true && false;// 출력 값 : false

//논리 OR 연산을 한다.
boolean c = true || false;// 출력 값 : true
비트 연산자와 논리 연산자의 차이
비트 연산자를 사용하는 경우 앞 뒤 피연산자를 모두 확인하여 비교하지만 논리 연산자를 사용하는 경우 앞의 값에 따라 뒤의 값을 확인하지 않을 수도 있다.

예를 들어 AND 연산을 할 때 false & false 의 경우 앞에 false와 뒤의 false 값 양쪽 모두 확인하고 비교한다. 하지만 false && false의 경우 앞에 false가 나왔기 때문에 뒤의 값을 확인하지 않고 결과 값인 false를 반환한다.

6.Instanceof

객체가 특정 타입인지 확인하는 연산자. 왼쪽의 피연산자가 오른쪽의 피연산자 타입인지 확인한다. 결과는 부울 값을 반환한다. 왼쪽의 피연산자가 오른쪽의 서브 타입인 경우도 참을 반환한다.

String s = new String();
boolean a = s instanceof String;//출력 값 : true
boolean b = s instanceof Object;//출력 값 : true

7.Assignment(=) operator
할당 연산자. 왼쪽의 피연산자에 오른쪽 피연산자를 할당한다. 피연산자는 타입이 호환 가능해야한다. 프리미티브 타입인 경우 값을 할당하고 레퍼런스 타입인 경우 참조를 할당한다. 다른 연산자랑 같이 사용 할 수도 있다.

같이 사용 할 수 있는 연산자 : +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, |=, ^=

같이 연산자를 사용하면 a (연산자)= b 인 경우 a = a (연산자) b 와 같다.

int a = 1;//출력 값 : 1

//a = a + 1
a += 1;//출력 값 : 2

8.화살표(->) 연산자

람다 표현식. 자바8 부터 도입된 연산자. 함수형 인터페이스에서만 사용 할 수 있다. 익명 함수에 사용한다. 인터페이스가 가지고 있는 메서드를 객체를 생성하지 않아도 즉흥적으로 구현해서 사용 할 수 있다. 간결한 코드를 작성할 수 있고 가독성이 향상되지만 재사용이 불가능하고 디버깅이 어렵다.

(매개변수목록) ->{실행문/리턴문} 형태를 띈다. 실행문만 있는 경우 괄호를 생략 할 수 있다.

interface Foo{
int plus(int a, int b);
}
함수형 인터페이스 : 인터페이스에 함수가 1개만 있는 인터페이스

//기존 방식으로 구현
Foo foo1 = new Foo() {
@Override
public int plus(int a, int b) {
return a + b;
}
};

//람다식을 이용한 구현
Foo foo2 = (int a, int b) -> a+b;

int a = foo1.plus(1, 2);//출력 값 : 3
int b = foo2.plus(1, 2);//출력 값 : 3

9.3항 연산자

피연산자가 3개인 연산자. {조건} ? {참일 경우 실행} : {거짓일 경우 실행} 의 형태를 띈다.

int a = 1;
int b = (a > 0) ? 2 : 3;//출력 값 : 

연산자 우선 순위

여러개의 연산자가 같이 있는경우 우선순위에 따라 먼저 실행 순서가 달라진다.

1)최우선연산자 ., [], ()

2)단항연산자 ++,--,+,-,~,!

3)산술연산자 *,/,%,+,-

4)시프트연산자 >>,<<,>>>

5)비교연산자 >,<,>=,<=,==,!=

6)비트연산자 &,^,|

7)논리연산자 &&,||

8)삼항연산자 ? :

9)대입연산자 =, +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, |=, ^=